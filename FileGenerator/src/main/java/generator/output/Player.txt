import java.util.*;
import java.io.*;
import java.math.*;
import static java.util.stream.Collectors.toList;



final class Game {

	private int myScore;
	private int opponentScore;

	private final MapManager mapManager;

	private int visiblePacCount;
	List<PacMan> pacs = new ArrayList<>();

	private int visiblePelletCount;

	private Game(final MapManager mapManager) {
		this.mapManager = mapManager;
	}

	static Game create(final MapManager mapManager) {
		return new Game(mapManager);
	}

	void updateParameters(final Scanner input) {
		myScore = input.nextInt();
		opponentScore = input.nextInt();
		visiblePacCount = input.nextInt(); // all your pacs and enemy pacs in sight
		setPacs(input);
		visiblePelletCount = input.nextInt(); // all pellets in sight
		setPellets(input);
	}

	private void setPacs(final Scanner input) {
		for (int i = 0; i < visiblePacCount; i++) {
			final int pacId = input.nextInt(); // pac number (unique within a team)
			final boolean mine = input.nextInt() != 0; // true if this pac is yours
			final Position position = new Position(input.nextInt(), input.nextInt());
			final String typeId = input.next(); // unused in wood leagues
			final int speedTurnsLeft = input.nextInt(); // unused in wood leagues
			final int abilityCooldown = input.nextInt(); // unused in wood leagues

			final Optional<PacMan> possiblePac = pacs.stream().filter(p -> p.getId() == pacId && p.isMine() == mine)
					.findFirst();
			if (!possiblePac.isPresent()) {
				pacs.add(PacMan.create(pacId, mine, position, typeId));
				continue;
			}

			final PacMan pac = possiblePac.get();
			pac.setPosition(position);
		}
	}

	private void setPellets(final Scanner input) {

		// Resetar posicao dos pellets
		mapManager.clearMap();

		for (int i = 0; i < visiblePelletCount; i++) {
			final Position position = new Position(input.nextInt(), input.nextInt());
			final int value = input.nextInt();
			mapManager.updateMapOnPosition(position, OccupationType.getPelletType(value));
		}
	}

	String run(final MapManager mapManager) {
		final List<PacMan> minePacs = pacs.stream().filter(p -> p.isMine()).collect(toList());
		final List<String> moves = minePacs.stream()
				.map(p -> p.move(mapManager.getClosestSP(p.getPosition())))
				.collect(toList());
		return String.join(" | ", moves);
	}

}

 final class Cell {

	private final CellType type;
	private OccupationType occupation;

	private Cell(final CellType type) {
		this.type = type;
	}

	public static Cell getCell(final String code) {
		return new Cell(CellType.getCell(code));
	}

	public CellType getType() {
		return type;
	}

	public OccupationType getOccuppation() {
		return occupation;
	}

	public void setOccupation(final OccupationType occupation) {
		this.occupation = occupation;
	}

}


enum CellType {
	FLOOR(" "), WALL("#");

	private final String code;

	private CellType(final String code) {
		this.code = code;
	}

	static CellType getCell(final String code) {
		final Optional<CellType> cell = Arrays.stream(CellType.values()).filter(c -> c.getCode().equalsIgnoreCase(code))
				.findFirst();
		if (!cell.isPresent()) {
			throw new IllegalArgumentException("Invalid Cell Type");
		}
		return cell.get();
	}

	public String getCode() {
		return code;
	}

}


final class Map {

	private final int mapWidth;
	private final int mapHeight;

	// top left corner is (x=0, y=0)
	private final Cell[][] map;

	public Map(final int width, final int height) {
		mapWidth = width;
		mapHeight = height;
		map = new Cell[mapWidth][mapHeight];
	}

	public Cell[][] getMap() {
		return map;
	}

	public int getMapWidth() {
		return mapWidth;
	}

	public int getMapHeight() {
		return mapHeight;
	}

	void setMapPosition(final Position position, final Cell cell) {
		map[position.getX()][position.getY()] = cell;
	}

	void updateMap(final Position position, final OccupationType occupation) {
		final Cell cell = map[position.getX()][position.getY()];
		cell.setOccupation(occupation);
	}

	List<Position> getPositionWithOccupationType(final OccupationType occupation) {
		final ArrayList<Position> positions = new ArrayList<Position>();
		for (int x = 0; x < mapWidth; x++) {
			for (int y = 0; y < mapHeight; y++) {
				if (map[x][y].getOccuppation().equals(occupation)) {
					positions.add(Position.create(x, y));
				}
			}
		}
		return positions;
	}
}


 class MapManager {

	private final Map map;

	private MapManager(final Map map) {
		this.map = map;
	}

	public static MapManager createMap(final int mapWidth, final int mapHeight) {
		return new MapManager(new Map(mapWidth, mapHeight));
	}

	public void setMap(final int line, final String lineInfo) {
		for (int i = 0; i < map.getMapWidth(); i++) {
			final String code = String.valueOf(lineInfo.charAt(i));
			final Cell cell = Cell.getCell(code);
			map.setMapPosition(Position.create(i, line), cell);
		}
	}

	public void updateMapOnPosition(final Position position, final OccupationType pellet) {
		map.updateMap(position, pellet);
	}

	public void clearMap() {
		for (int x = 0; x < map.getMapWidth(); x++) {
			for (int y = 0; y < map.getMapHeight(); y++) {
				map.updateMap(Position.create(x, y), OccupationType.EMPTY);
			}
		}
	}

	private final Position close = null;

	public Position getClosestSP(final Position position) {
		if (close != null && close.distanceTo(position) == 0) {
			return close;
		}

		final List<Position> positions = map.getPositionWithOccupationType(OccupationType.SUPER_PELLET);
		final Optional<Position> min = positions.stream().min((p1, p2) -> position.compare(p1, p2));
		return min.isPresent() ? min.get() : map.getPositionWithOccupationType(OccupationType.PELLET).get(0);
	}

}


 enum OccupationType {
	WALL("#", -1), EMPTY(" ", 0), PELLET("P", 1), SUPER_PELLET("SP", 10);

	private final String code;
	private final int value;

	private OccupationType(final String code, final int value) {
		this.code = code;
		this.value = value;
	}

	public static OccupationType getPelletType(final int value) {
		final Optional<OccupationType> pellet = Arrays.stream(OccupationType.values()).filter(p -> p.getValue() == value)
				.findFirst();
		if (!pellet.isPresent()) {
			throw new IllegalArgumentException("Invalid pallet value");
		}
		return pellet.get();
	}

	public String getCode() {
		return code;
	}

	public Integer getValue() {
		return value;
	}

}


 final class Position implements Comparator<Position> {

	private int x;
	private int y;

	private Position north;
	private Position south;
	private Position east;
	private Position west;

	public static final Position INVALID_POSITION = new Position(-1, -1);

	public Position(final int x, final int y) {
		this.x = x;
		this.y = y;
	}

	public static Position create(final int x, final int y) {
		return new Position(x, y);
	}

	public void setX(final int x) {
		this.x = x;
	}

	public int getX() {
		return x;
	}

	public void setY(final int y) {
		this.y = y;
	}

	public int getY() {
		return y;
	}

	public boolean isValid() {
		return x >= 0 && x < 12 && y >= 0 && x < 12;
	}

	public int distanceTo(final Position position) {
		return Math.abs(x - position.getX()) + Math.abs(y - position.getY());
	}

	public Position getNorthPosition() {
		if (north == null) {
			north = Position.create(x, y + 1);
		}
		return north;
	}

	public Position getSouthPosition() {
		if (south == null) {
			south = Position.create(x, y - 1);
		}
		return south;
	}

	public Position getEastPosition() {
		if (east == null) {
			east = Position.create(x + 1, y);
		}
		return east;
	}

	public Position getWestPosition() {
		if (west == null) {
			west = Position.create(x - 1, y);
		}
		return west;
	}

	@Override
	public boolean equals(final Object obj) {
		if (obj == null) {
			return false;
		}
		if (obj instanceof Position) {
			final Position pos = (Position) obj;
			if (this == pos) {
				return true;
			}
			if (x == pos.getX() && y == pos.getY()) {
				return true;
			}
		}
		return false;
	}

	@Override
	public int hashCode() {
		return Objects.hash(x, y);
	}

	@Override
	public String toString() {
		return "(x,y) = (" + x + "," + y + ")";
	}

	@Override
	public int compare(final Position p1, final Position p2) {
		return distanceTo(p1) - distanceTo(p2);
	}
}


 class PacMan {

	private final int id;
	private final boolean mine;
	private Position position;
	private final String typeId;
	private int speedTurnsLeft;
	private int abilityCooldown;

	private PacMan(final int id, final boolean mine, final Position position, final String typeId) {
		this.id = id;
		this.mine = mine;
		this.position = position;
		this.typeId = typeId;
	}

	public static PacMan create(final int id, final boolean mine, final Position position, final String typeId) {
		return new PacMan(id, mine, position, typeId);
	}

	public int getId() {
		return id;
	}

	public boolean isMine() {
		return mine;
	}

	public Position getPosition() {
		return position;
	}

	public void setPosition(final Position position) {
		this.position = position;
	}

	public String getTypeId() {
		return typeId;
	}

	public int getSpeedTurnsLeft() {
		return speedTurnsLeft;
	}

	public int getAbilityCooldown() {
		return abilityCooldown;
	}

	public String move(final Position position) {
		return "MOVE " + getId() + " " + position.getX() + " " + position.getY();

	}

}



 class Player {

	public static void main(final String args[]) {

		final Scanner input = new Scanner(System.in);

		final MapManager mapManager = generateMap(input);
		final Game game = Game.create(mapManager);

		// game loop
		while (true) {
			game.updateParameters(input);

			final String result = game.run(mapManager);

			System.out.println(result); // MOVE <pacId> <x> <y>
		}
	}

	private static MapManager generateMap(final Scanner input) {
		final int width = input.nextInt();
		final int height = input.nextInt();

		final MapManager mapManager = MapManager.createMap(width, height);
		if (input.hasNextLine()) {
			System.err.print(input.nextLine());
		}
		for (int line = 0; line < height; line++) {
			final String row = input.nextLine(); // one line of the grid: space " " is floor, pound "#" is wall
			mapManager.setMap(line, row);
		}
		return mapManager;
	}
}
