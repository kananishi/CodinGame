import java.util.*;
import java.io.*;
import java.math.*;
import static java.util.stream.Collectors.toList;
class Character {
	private final int id;
	private final Position currentPosition;

	public static Character ash = new Character(0, new Position(0, 0));

	public Character(final int id, final Position currentPosition){
		this.id = id;
		this.currentPosition = currentPosition;
	}

	public int getId() {
		return id;
	}

	public Position getCurrentPosition() {
		return currentPosition;
	}

	public double getDistanceTo(final Position position){
		final double dx = Math.pow(position.getX() - currentPosition.getX(), 2);
		final double dy= Math.pow(position.getY() - currentPosition.getY(), 2);
		return Math.sqrt(dx+dy);
	}
}

final class Game{

	private Game() {
	}

	final static Scanner input = new Scanner(System.in);

	private static int humansCount;
	private static List<Human> humans = new ArrayList<>(humansCount);
	private static int zombieCount;
	private static List<Zombie> zombies = new ArrayList<>(humansCount);

	// Pontuacao
	// If several zombies are destroyed during on the same round,
	// the nth zombie killed's worth is multiplied by the (n+2)th
	// number of the Fibonnacci sequence (1, 2, 3, 5, 8, and so on).
	// As a consequence, you should kill the maximum amount of zombies
	// during a same turn.
	int pointGainPerKill = (int)Math.pow(humansCount, 2) * 10;

	protected static void run(final Strategy strategy) {
		setParameters();
		move(strategy.run());
	}

	protected static void setParameters() {
		Character.ash.getCurrentPosition().setX(input.nextInt());
		Character.ash.getCurrentPosition().setY(input.nextInt());
		humansCount = input.nextInt();
		humans.clear();
		zombies.clear();
		for (int i = 0; i < humansCount; i++) {
			humans.add(Human.createHumanInCoordenates(input.nextInt(), input.nextInt(), input.nextInt()));
		}
		final int zombieCount = input.nextInt();
		for (int i = 0; i < zombieCount; i++) {
			final int zombieId = input.nextInt();
			final Position zombieCurrentPosition = new Position(input.nextInt(), input.nextInt());
			final Position zombieNextPosition = new Position(input.nextInt(),input.nextInt());
			zombies.add(Zombie.create(zombieId, zombieCurrentPosition, zombieNextPosition));
		}
	}

	private static void move(final Position destination) {
		System.out.println(String.format("%d %d", destination.getX(), destination.getY()));
	}


	public static void log( final Object message) {
		// To debug: System.err.println("Debug messages...");
		System.err.println(String.valueOf(message));
	}

	public static int getHumanCount() {
		return humansCount;
	}

	public static int getZombieCount() {
		return zombieCount;
	}

	public static List<Human> getHumans() {
		return humans;
	}

	public static List<Zombie> getZombies() {
		return zombies;
	}
}
final class Human extends Character{

	private Human(final int id, final Position position) {
		super(id,position);
	}

	public static Human createHumanInCoordenates(final int id, final int x, final int y) {
		return new Human(id, new Position(x,y) );
	}

	public double getDistanceToAsh(){
		return super.getDistanceTo(Character.ash.getCurrentPosition());
	}

	public double getDistanceToNearestZombie() {
		double distanceToNearestZombie = Double.MAX_VALUE;
		for (final Zombie zombie : Game.getZombies()) {
			final double distanceToZombie = zombie.getDistanceTo(super.getCurrentPosition());
			if(distanceToZombie < distanceToNearestZombie) {
				distanceToNearestZombie = distanceToZombie;
			}
		}
		return distanceToNearestZombie;
	}

	public boolean canBeSaved() {
		return Double.compare(stepsFromAsh(),stepsFromNearesZombie()) <= 0;
	}

	private double stepsFromAsh() {
		return (getDistanceToAsh() - Rules.ASHRANGE.getValue()) / Rules.ASHSTEP.getValue() ;
	}

	private double stepsFromNearesZombie() {
		return getDistanceToNearestZombie() / Rules.ZOMBIESSTEP.getValue();
	}

	@Override
	public String toString() {
		return "Id: " + getId() + "Position: " + getCurrentPosition();
	}

}

class Player {

	public static void main(final String args[]) {
		while (true) {
			Game.run(Strategy.SaveHumansInDanger);
		}
	}
}

final class Position{
	private int x;
	private int y;

	public Position(final int x, final int y) {
		this.x = x;
		this.y = y;
	}

	public static Position create(final int x, final int y){
		return new Position(x, y);
	}

	public void setX(final int x) {
		this.x = x;
	}

	public int getX() {
		return x;
	}

	public void setY(final int y) {
		this.y = y;
	}

	public int getY() {
		return y;
	}

	@Override
	public String toString() {
		return "(x,y) = (" + x + "," + y + ")" ;
	}
}

enum Rules {
	WIDE( 16000),
	HIGH( 9000),
	ASHSTEP(1000),
	ASHRANGE( 2000),
	ZOMBIESSTEP(400);

	private int value;

	private Rules(final int value) {
		this.value = value;
	}

	int getValue() {
		return value;
	}


}


enum Strategy{
	SaveNearestHuman {
		@Override
		public Position run() {
			final Optional<Human> nearestHuman = Game.getHumans().stream()
					.min((first, second) -> Double.compare(first.getDistanceToAsh(),second.getDistanceToAsh()));
			if(nearestHuman.isPresent()) {
				return nearestHuman.get().getCurrentPosition();
			}
			return null;
		}
	},
	SaveOnlyWhoCanBeSaved{
		@Override
		public Position run() {
			final Optional<Human> nearestHuman = getRescueableHumans().stream()
					.min((first, second) -> Double.compare(first.getDistanceToAsh(), second.getDistanceToAsh()));
			if(!nearestHuman.isPresent()) {
				Game.log("Save nearest human");
				return SaveNearestHuman.run();
			}
			return nearestHuman.get().getCurrentPosition();
		}
	},
	SaveHumansInDanger{
		@Override
		public Position run() {
			final List<Human> rescuableHumans = getRescueableHumans();
			rescuableHumans.sort((first,second) -> (int)(first.getDistanceToAsh() - second.getDistanceToAsh()));
			rescuableHumans.forEach(h -> Game.log(String.valueOf(h.getDistanceToAsh())));
			return rescuableHumans.get(rescuableHumans.size()-1).getCurrentPosition();
		}
	};

	public static List<Human> getRescueableHumans() {
		return Game.getHumans().stream()
				.filter(human -> human.canBeSaved())
				.collect(toList());
	}

	public abstract Position run();
}
final class Zombie extends Character{
	private final Position nextPosition;

	private Zombie(final int id, final Position currentPosition, final Position nextPosition) {
		super(id, currentPosition);
		this.nextPosition = nextPosition;
	}

	public static Zombie create(final int id, final Position currentPosition, final Position nextPosition) {
		return new Zombie(id, currentPosition, nextPosition);
	}

	public Position getNextPosition() {
		return nextPosition;
	}

	protected double getDistanceToNextPosition() {
		return super.getDistanceTo(nextPosition);
	}

}
